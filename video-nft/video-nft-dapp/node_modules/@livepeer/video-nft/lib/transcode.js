"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDesiredProfile = void 0;
const inquirer_1 = __importDefault(require("inquirer"));
const openSeaNftSizeLimit = 100000000; // 100 MB
const min720pBitrate = 500000; // 0.5 Mbps
const minBitrate = 100000; // 0.1 Mbps
async function getDesiredProfile(asset) {
    var _a, _b, _c, _d, _e, _f;
    const size = (_a = asset.size) !== null && _a !== void 0 ? _a : 0;
    const videoTrack = (_c = (_b = asset.videoSpec) === null || _b === void 0 ? void 0 : _b.tracks) === null || _c === void 0 ? void 0 : _c.find(t => t.type === 'video');
    const { bitrate, width, height } = videoTrack !== null && videoTrack !== void 0 ? videoTrack : {};
    if (size <= openSeaNftSizeLimit || !bitrate || !width || !height) {
        return null;
    }
    const audioTrack = (_e = (_d = asset.videoSpec) === null || _d === void 0 ? void 0 : _d.tracks) === null || _e === void 0 ? void 0 : _e.find(t => t.type === 'audio');
    const audioBitrate = (_f = audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.bitrate) !== null && _f !== void 0 ? _f : 0;
    const desiredBitrate = Math.floor((bitrate + audioBitrate) * (openSeaNftSizeLimit / size) - audioBitrate);
    if (desiredBitrate < minBitrate) {
        console.error(`Warning: Asset is larger than OpenSea file limit so the video won't playback automatically. ` +
            `It will still be stored in IPFS and referenced in the NFT metadata, so a proper application is still able to play it back. ` +
            `For more information check http://bit.ly/opensea-file-limit`);
        return null;
    }
    console.log(`File is too big for OpenSea 100MB limit (learn more at http://bit.ly/opensea-file-limit).`);
    const { action } = await inquirer_1.default.prompt({
        type: 'list',
        name: 'action',
        message: 'What do you want to do?',
        choices: [
            {
                value: 'transcode',
                name: 'Transcode it to a lower quality so OpenSea is able to preview'
            },
            {
                value: 'ignore',
                name: 'Mint it as is (should work in any other platform that uses the NFT file)'
            }
        ]
    });
    if (action === 'ignore') {
        return null;
    }
    // We only change the resolution if the bitrate changes too much. We don't go
    // below 720p though since the bitrate is the thing that really matters. We
    // don't need to handle aspect ratio since go-livepeer will do it for us.
    const referenceHeight = height * Math.sqrt(desiredBitrate / bitrate);
    const resolution = height < 480 || referenceHeight > 720
        ? { name: 'low-bitrate', width, height }
        : desiredBitrate < min720pBitrate
            ? { name: '480p', width: 854, height: 480 }
            : { name: '720p', width: 1280, height: 720 };
    return {
        ...resolution,
        bitrate: desiredBitrate,
        fps: 0
    };
}
exports.getDesiredProfile = getDesiredProfile;
